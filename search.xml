<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[人生最美是清欢]]></title>
    <url>%2F2019%2F05%2F%E4%BA%BA%E7%94%9F%E6%9C%80%E7%BE%8E%E6%98%AF%E6%B8%85%E6%AC%A2%2F</url>
    <content type="text"><![CDATA[人间有味，最是清欢细雨斜风作小寒，淡烟疏柳媚晴滩，入淮清洛渐漫漫。雪沫乳花浮午盏，蓼茸篙笋试春盘，人间有味是清欢。 ——苏轼 人生只似风前絮，欢也零星，悲也零星，都做连江点点萍。 ——王国维 山中何所有？领上多白云。只可自怡悦，不堪持赠君。 天寒翠袖薄，日暮倚修竹。 怎么向从来没见过雪的人描述雪？ 我们要知道雪，只有自己到有雪的国度；我们要听到黄莺的歌声，就要坐到有黄莺的树下；我们要问夜来香的清气，只有夜晚走到有花的庭院。 雪，冷面清明，纯净优美，念念不往，在某一层次上，像极了我们的心。 活在当下，自在宁静山有多高，月就有多小；云有多重，愁就有多深；而夕阳 夕阳就只有一寸 我们为了太多紧急的事，只好牺牲看来不甚紧急的事，例如为了加班，牺牲应有的睡眠；为了业绩牺牲吃饭时间；为了应酬，不能陪家人散步，为了谋取职位，不能与朋友喝茶。确实，紧急的事不能不做，奈何人生里紧急的事无穷无尽，我们的一生大半的在紧急的应付中度过，到最后整个生活步调都变得很紧急了。 一个人如果在一天里花了八个小时在追逐衣食与俗世上，是不是也能画八十分钟来思考重要的事情呢？如若不行，就从八分钟开始。 天寒露重，望君保重风来疏竹，风过而竹不留声；雁渡寒潭，雁去而潭不留影。故君子事来而心始现，事去而心随空。 爱的开始是一个眼色，爱的最后是无限的苍穹 简单 而有丰沛的爱平常 而有深刻的心 岁月静好，随遇而安温柔半两，从容一生正视每一个眼前的生活历程，努力地活在当下，对这一阶段的人生与情感用心珍惜。 在被造谣时，我不着急，因为我有自知之明；在被误解时，我不着急，因为我有自觉之道；在被毁谤时，我不着急，因为我有自爱之方；在被打击时，我不着急，因为我有自愉之法。 生命的一切成长，都需要时间。 生命的幸福原来不在于人的环境、人的地位、人所能享受的物质，而在于人的心灵如何与生活应对。 我们幸福的感受不全然是世界所给予的，而是来自我们对外在或者内在的价值判断。我们幸福与否，正是由自我的价值观来决定。 不忘初心，方得始终万事万物都有其自然的法则，依循这自然的发展，常常回头看看自己的脚跟，才是生命成长正常的态度。“不雨花犹落，无风絮自飞”，花与絮的飞落不必因为风雨，而是它已进入了生命的时序。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>名句摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2019%2F05%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[概念Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 工作区：在电脑里能看到的目录 版本库：版本库里包含被称为stage的暂存区以及git自动创建的第一个分支master以及指向master的一个指针HEAD。 初始化配置 安装好git之后通过如下命令配置用户名和email 12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 查看配置内容 123$ git config --system --list # 查看系统config$ git config --global --list # 查看用户config$ git config --local --list # 查看本地仓库config 创建及管理修改 初始化一个Git仓库，使用git init命令。 123$ mkdir learngit$ cd learngit$ git init 添加文件到git仓库 方式1：先添加到暂存区，再提交 1234$ git add &lt;file&gt;$ git rm -cached &lt;file&gt; # 取消添加，可以从暂存区删除文件$ git commit -m "description" 方式2：直接提交 1$ git commit -a -m "description" 直接覆盖上一次提交信息 1$ git commit -a --amend #只会有一次提交 信息查询跟踪工作区的修改12$ git status # 列出哪些文件被修改$ git diff &lt;file&gt; # 文件被修改的内容 查看提交记录12$ git log # 提交记录$ git reflog # 记录每一次修改操作 git log的常用选项说明 选项 说明 -p 按补丁格式显示每个更新之间的差异。 –stat 显示每次更新的文件修改统计信息。 –shortstat 只显示 –stat 中最后的行数修改添加移除统计。 –name-only 仅在提交信息后显示已修改的文件清单。 –name-status 显示新增、修改、删除的文件清单。 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 –graph 显示 ASCII 图形表示的分支合并历史。 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和format（后跟指定格式）。 版本回退 指定版本号 1$ git reset --hard commit_id commit_id可用 git log 和 git reflog 两个命令来查询，一般填写前7位即可，git会自动去匹配，知识要保证提供的commit_id可被git区分。 相对版本回退 1$ git reset --hard HEAD^ 在Git中，用HEAD表示当前版本，一般指向最新的提交的版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 撤销修改 修改了工作区的文件还没有提交到缓存区 1git checkout -- file命令。 命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，在后面的分支管理中会再次遇到git checkout命令。 修改了工作区文件并提交到了缓存区，但是没有使用commit提交到分支上1) 用命令 git reset HEAD file 就回到了场景12) 按场景1操作 12$ git reset HEAD readme.txt$ git checkout -- readme.txt 已经提交到了版本库的分支上，参考版本回退章节的内容 删除文件Git中删除也是一个修改操作。直接删除本地文件后，工作区和版本库不一致，这时候有两种选择： 删除版本库中相应的文件 12$ git rm &lt;file&gt;$ git commit -m "Remove" 从版本库中恢复被删除的文件 1$ git checkout -- &lt;file&gt; 分支管理Git鼓励大量使用分支 分支常用操作 查看分支： 1$ git branch # 加-v后缀可查看每一个分支的最后一次提交 创建分支 1$ git branch &lt;branch name&gt; 切换分支： 1$ git checkout &lt;branch name&gt; 在切换分支时，一定要注意你工作目录里的文件会被改变。如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。 创建+切换分支： 1$ git checkout -b [branch] [remote name]/[branch] 合并某分支到当前分支： 1$ git merge &lt;branch name&gt; 删除分支： 1$ git branch -d &lt;branch name&gt; 删除远程分支： 1git push [remote name] --delete [remote branch] 变基（rebase）将当前分支合并到其他分支并使得提交历史变得简洁 将分支b变基到分支a上过程如下： 12345$ git checkout &lt;branch b&gt;$ git rebase &lt;branch a&gt;# 以下两步用于前移a分支的head$ git checkout &lt;branch a&gt;$ git merge &lt;branch b&gt; 解决rebase冲突 1234$ git diff$ # 修改冲突的内容$ git add &lt;file&gt;$ git rebase --continue 远程仓库 关联远程仓库 12345$ git remote add origin &lt;远程仓库地址&gt; # 添加远程仓库$ git remote -v # 查看远程仓库信息$ git remote rm &lt;仓库名&gt; # 删除远程仓库$ git remote &lt;仓库名&gt; set-url &lt;远程仓库地址&gt; # 修改远程仓库的链接$ git remote rename &lt;remote-name&gt; &lt;new-name]&gt; # 远程仓库重命名 抓取与推送 git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 从远程仓库指定分支中拉取所有你还没有的数据保存到本地分支中。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 自动的抓取然后合并远程分支到当前分支 git push &lt;remote-name&gt; &lt;branch-name&gt; 将当期分支推送到远程仓库的指定分支中 git push -u origin master 第一次推送master分支的所有内容；（加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。） 远程仓库强制覆盖本地修改 123$ git fetch -all$ git reset --hard origin/master # 指定远程分支origin/dev_liutao$ git pull origin dev_liutao 推送修改到远程仓库 123$ git fetch$ git rebase origin/master$ git push]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>版本管理</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL队列]]></title>
    <url>%2F2019%2F05%2FSTL%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[头文件1#include&lt;queue&gt; 构造函数1queue&lt;T&gt; que; 成员函数123456void push(const value_type&amp; val); // 将元素置入queue中。 void pop(); // 会从queue中移除一个元素（也就是第一个被置入的元素）。value_type front(); // 会返回queue内的下一个元素（也就是第一个被置入的元素）。value_type back(); // 会返回queue的最后一个元素（也就是最后一个被插入的元素）。size_type size() const; // 返回stack长度。bool empty() const; // 返回stack是否为空。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL向量]]></title>
    <url>%2F2019%2F05%2FSTL%E5%90%91%E9%87%8F%2F</url>
    <content type="text"><![CDATA[头文件1#include &lt;vector&gt; 声明及初始化12345678910vector&lt;int&gt; vec; // 声明一个int型向量vector&lt;int&gt; vec(5); // 声明一个初始大小为5的int向量，向量元素执行默认初始化vector&lt;int&gt; vec(10, 1); // 声明一个初始大小为10且值都是1的向量vector&lt;int&gt; vec(tmp); // 声明并用tmp向量初始化vec向量vector&lt;int&gt; tmp(vec.begin(), vec.begin() + 3); // 用向量vec的第0个到第2个值初始化tmpint arr[5] = &#123;1, 2, 3, 4, 5&#125;;vector&lt;int&gt; vec(arr, arr + 5); /* 将arr数组的元素用于初始化vec向量(说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，这个主要是为了和vec.end()指针统一。)*/vector&lt;int&gt; vec(&amp;arr[1], &amp;arr[4]); // 将arr[1]~arr[4]范围内的元素作为vec的初始值 基本操作容量（capacity）与长度（size）size指容器当前拥有的元素个数；capacity则指容器在必须分配新存储空间之前可以存储的元素总数,也可以说是预分配存储空间的大小。 向量长度：vec.size(); 向量支持的最大容量： vec.max_size(); 更改向量长度： 12vec.resize(n); // 将向量的大小改为n。（当n小于当前长度则擦除后续部分，但vec的容量不变；n大于当前长度则插入新元素，新元素设为默认值；若n超出当前向量分配的容量，则会将当前容量扩容至n。）vec.resize(n, t); // 作用与上一函数相同，只是将新元素的值设置为t 保留适当容量：vec.reserve(n); // 预分配n个元素的存储空间。（当n大于当前容量时则将容量扩充至n；当n小于等于当前容量时则无变化。容器调用resize()函数后，所有空间都已经初始化可以直接访问，而调用reserve()函数预先分配出的空间没有被初始化，所以不可以直接访问） 向量真实容量：vec.capacity(); 向量判空： vec.empty(); 减少向量容量到满足元素所占存储空间的大小： vec.shrink_to_fit(); //shrink_to_fit 修改 多元素赋值：vec.assign(iterator first, iterator last) // 将[first, last)之间的值赋值给vec 末尾添加元素：void vec.push_back(elem) 末尾删除元素：void vec.pop_back(elem) 插入元素： iterator vec.insert() // 返回一个指向第一个新插入元素的迭代器 12345iterator insert (const_iterator position, const value_type&amp; val); //single elementiterator insert (const_iterator position, size_type n, const value_type&amp; val); // fill iterator insert (const_iterator position, InputIterator first, InputIterator last); // rangeiterator insert (const_iterator position, value_type&amp;&amp; val); //moveiterator insert (const_iterator position, initializer_list&lt;value_type&gt; il); //initializer list 任意位置删除元素： vec.erase(); 交换两个向量的元素： vec.swap(); 清空向量元素： vec.clear(); 迭代器12345678910iterator vec.begin();iterator vec.end(); //末尾指针，指向最后一个元素的下一个位置const_iterator vec.cbegin(); /*指向常量的开始指针，意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。*/const_iterator vec.cend(); //指向常量的末尾指针reverse_iterator vec.rbegin() //逆向迭代器的开始指针reverse_iterator vec.rend(); //逆向迭代器的尾指针const_reverse_iterator vec.crbegin() //逆向迭代器的开始指针,指向常量const_reverse_iterator vec.crend(); //逆向迭代器的尾指针,指向常量 元素访问 下标访问： vec[1]; //并不会检查是否越界 at方法访问： vec.at(1); //以上两者的区别就是at会检查是否越界，是则抛出out of range异常 访问第一个元素： vec.front(); 访问最后一个元素： vec.back(); 返回一个指针： int* p = vec.data(); //可行的原因在于vector在内存中就是一个连续存储的数组，所以可以返回一个指针指向这个数组。这是是C++11的特性。 应用 遍历元素 1234567vector&lt;int&gt;::iterator it;for (it = vec.begin(); it != vec.end(); it++) cout &lt;&lt; *it &lt;&lt; endl;//或者for (size_t i = 0; i &lt; vec.size(); i++) &#123; cout &lt;&lt; vec.at(i) &lt;&lt; endl;&#125; 元素翻转 12#include &lt;algorithm&gt;reverse(vec.begin(), vec.end()); 元素排序 12345#include &lt;algorithm&gt;sort(vec.begin(), vec.end()); //采用的是从小到大的排序//如果想从大到小排序，可以采用上面反转函数，也可以采用下面方法:bool Comp(const int&amp; a, const int&amp; b) &#123;return a &gt; b;&#125;sort(vec.begin(), vec.end(), Comp);]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL简介]]></title>
    <url>%2F2019%2F04%2FSTL%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[STL（Standard Template Library）标准模板库的简称，是由惠普开发的一系列软件的总称，STL现在是C++的一部分，已经被构建于编译系统之内，所以不需要再引入。 STL的组成部分 容器（containers）：是一种数据结构容器，使用类模板的方式提供，我们可以方便的进行数据的存储操作。 适配器（adapters）：以序列式容器为基础，提供的栈，队列和优先级队列的这种容器。 迭代器（iterators）：类似于指针，用来操作容器的对象。 算法（algorithm）：包含一系列的常见算法。 空间配置器（allocator）：其中主要工作包括两部分：1、对象的创建与销毁。2、内存的创建与释放。 仿函数（functor）：仿函数又称为函数对象，其实就是重载了()操作符的struct，没有什么特别的地方。 容器 序列式容器：每个元素都有固定位置，取决于插入时机和地点。与元素值无关。 vector（向量）：底层数据结构是数组，可以随机存取数据元素（用索引直接存取），数组的尾部添加和移除元素很快，但在头部和中部插入元素比较耗时。 deque（双端队列）：底层数据结构是数组，可以随机存取数据元素，在数组的头部和尾部插入和删除元素很快。 list（列表）：底层数据结构是双向链表，不提供随机存取数据元素（需要按顺序走到要存取的元素），在任何位置插入和删除都很快，只需要简单的移动一下指针。 forward_list：单向链表 array：固定大小的数组 string：字符串 关联式容器：元素位置取决于特定的排序准则，和插入的顺序无关，底层数据结构为二叉树。 set（集合）：内部元素依据其值自动排序，set内相同的数值元素只能出现一次。 multiset（多重集合）：内部元素依据其值自动排序，set内允许出现重复的元素。 map（映射）：map的元素是成对的键值对，内部元素的值依据键自动排序，键只允许出现一次。 multimap（多重映射）：多重映射是map的增强版，内部元素的值依据键自动排序，允许键出现多次。 bitset 无序的关联式容器，使用hash函数来组织元素 unordered_set unordered_map unordered_multiset unordered_multimap 适配器STL提供了三种适配器stack，queue和priority_queue。这些适配器是包装了序列式容器（vector，deque，list）中的一种。因此所谓的适配器就是序列式容器的包装器，注意：适配器没有提供迭代器。 stack（栈）：栈可以使用序列式容器中的vector，deque，list中的任意一种作为其底层的数据结构。默认是使用deque来实现的stack。 queue（队列）：队列可以使用deque和list中的任意一种作为其底层的数据结构。默认是使用deque来实现的queue。 priority_queue（优先队列）：优先队列也是一种队列，不过在进入队列之后会对元素进行排序，可以使用vector和deque来实现其底层结构，默认是使用vector来实现priority_queue。 名称 底层数据结构 查询速度 插入和删除的速度 序列式容器 vector（向量） 数组 快 尾部插入删除快，其他慢 deque（双端队列） 数组 快 头尾插入删除快，其他慢 list（列表） 链表 慢 任何位置插入删除都很快 容器适配器 stack（栈） deque（默认） ~ ~ queue（队列） deque（默认） ~ ~ priority_queue（优先队列） vector（默认） ~ ~ 关联式容器 set（集合） 二叉树 很快 ~ multiset（多重集合） 二叉树 很快 ~ map（映射） 二叉树 很快 ~ multimap（多重映射） 二叉树 很快 ~ 迭代器迭代器(Iterator)是指针(pointer)的泛化，它允许程序员以相同的方式处理不同的数据结构(容器)。STL中有五种类型的迭代器，它们分别满足一定的要求。不同的迭代器要求定义的操作不一样。 输入迭代器(Input iterator) 输出迭代器(Output iterator) 前向迭代器(Forward iterator) 双向迭代器(Bidirectional iterator) 随机访问迭代器(Random access iterator) 各个迭代器之间的功能关系如下图所示，越往下越丰富 input output \ / forward | bidirectional | random access]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客操作]]></title>
    <url>%2F2019%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[搭建步骤 安装node.js和git 安装Hexo 1$ npm install -g hexo-cli 建站 1234$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install$ hexo s // 本地运行，通过浏览器预览 新建博文 123$ hexo new "My New Post"$ hexo clean$ hexo generate 部署到远端站点 编辑站点配置文件_config.yml 123456#Deployment#Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/liuxiutao/liuxiutao.github.io.git branch: master 部署 1$ Hexo deploy NexT主题 下载主题 1$ git clone https://github.com/theme-next/hexo-theme-next themes/next/ 修改主题配置文件配置主题 常用命令 新建博文 1$ hexo new "My New Post" 更多信息: Writing 本地运行服务 1$ hexo server More info: Server 调试模式 1$ hexo s --debug 清空历史记录 1$ hexo clean 生成静态文件 1$ hexo generate More info: Generating 部署到远端站点 1$ hexo deploy More info: Deployment 新建分类页面 1$ hexo new page categories]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
