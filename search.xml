<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[STL string类型]]></title>
    <url>%2F2019%2F05%2FSTL-string%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[头文件1#include&lt;string&gt; 初始化 table th:first-of-type { width: 120px; } 类型 调用方法 default (1) string(); copy (2) string (const string&amp; str); substring (3) string (const string&amp; str, size_t pos, size_t len = npos); from c-string (4) string (const char* s); from buffer (5) string (const char* s, size_t n); fill (6) string (size_t n, char c); range (7) template &lt;class InputIterator&gt; string (InputIterator first, InputIterator last); initializer list (8) string (initializer_list&lt;char&gt; il); move (9) string (string&amp;&amp; str) noexcept; 123456strint s1;string s2("value");string s2 = "value";string s3(s2);string s3 = s2;string s4(10, 'c'); string类型可以和字符串或者字符相加得到连接串，但要求+号两边至少有一个是string类型的，如：12345string s1 = "hello";string s2 = s1 + "world";string s3 = "hi" + s1;string s4 = s1 + '\n';string s5 = "Hello" + "world"; //错误，不能直接将两个字面值相加 字符判断函数引入头文件 #include&lt;cctype&gt; isalnum(c) 当c是字母或者数字时为真 isalpha(c) 当c是字母时为真 isdigit(c) 当c是数字时为真 islower(c) 当c是小写字母时为真 isupper(c) 当c是大写字母时为真 isspace(c) 当c是空白字符（空格、’\t’、’\n’等）时为真 tolower(c) 将c转换成小写字符 toupper(c) 将c转换成大写字符 常用成员函数：insert 插入字符串 种类 调用方式 string (1) string&amp; insert (size_t pos, const string&amp; str); substring (2) string&amp; insert (size_t pos, const string&amp; str, size_t subpos, size_t sublen); c-string (3) string&amp; insert (size_t pos, const char* s); buffer (4) string&amp; insert (size_t pos, const char* s, size_t n); fill (5) string&amp; insert (size_t pos, size_t n, char c); iterator insert (const_iterator p, size_t n, char c); single character (6) iterator insert (const_iterator p, char c); range (7) template &lt;class InputIterator&gt; iterator insert (iterator p, InputIterator first, InputIterator last); initializer list (8) string&amp; insert (const_iterator p, initializer_list&lt;char&gt; il); erase 擦除字符串 string&amp; erase (size_t pos = 0, size_t len = npos); iterator erase (iterator first, iterator last); replace 替换详见http://www.cpluslus.com/reference/string/string/replace/ 类型 调用方式 string (1) string&amp; replace (size_t pos, size_t len, const string&amp; str); string&amp; replace (const_iterator i1, const_iterator i2, const string&amp; str); substring (2) string&amp; replace (size_t pos, size_t len, const string&amp; str, size_t subpos, size_t sublen); c-string (3) string&amp; replace (size_t pos, size_t len, const char* s); string&amp; replace (const_iterator i1, const_iterator i2, const char* s); buffer (4) string&amp; replace (size_t pos, size_t len, const char* s, size_t n); string&amp; replace (const_iterator i1, const_iterator i2, const char* s, size_t n); fill (5) string&amp; replace (size_t pos, size_t len, size_t n, char c); string&amp; replace (const_iterator i1, const_iterator i2, size_t n, char c); range (6) template &lt;class InputIterator&gt; string&amp; replace (const_iterator i1, const_iterator i2, InputIterator first, InputIterator last); initializer list (7) string&amp; replace (const_iterator i1, const_iterator i2, initializer_list&lt;char&gt; il); append 追加在尾部追加字符串，s1.append(s2)详情见http://www.cplusplus.com/reference/string/string/append/ 类型 调用方式 string (1) string&amp; append (const string&amp; str); substring (2) string&amp; append (const string&amp; str, size_t subpos, size_t sublen); c-string (3) string&amp; append (const char* s); buffer (4) string&amp; append (const char* s, size_t n); fill (5) string&amp; append (size_t n, char c); range (6) template &lt;class InputIterator&gt; string&amp; append (InputIterator first, InputIterator last); initializer list(7) string&amp; append (initializer_list&lt;char&gt; il); find 查找find 从pos位置开始搜索字符串，并返回一个位置，没有找到返回 string::npos123456size_t find (const string&amp; str, size_t pos = 0) const;size_t find (const char* s, size_t pos = 0) const;size_t find_first_of(const string&amp; str, size_t pos = 0); //从pos位置开始搜索，查找第一个在 str中出现的字符的位置 size_t find_last_of(str, pos=0); //从pos位置开始搜索，查找最后一个在 str中出现的字符的位置size_t find_first_not_of(str, pos=0); //从pos位置开始搜索，查找第一个不在str中出现的字符的位置size_t find_last_not_of(str, pos=0); //从pos位置开始搜索，查找最后一个不在str中出现的字符的位置 compare 比较s1.compare(s2)返回值 返回值 意义 >0 s1 &gt; s2 =0 s1 = s2 &lt;0 s1 &lt; s2 其他函数 length() 得到字符串的大小 empty() 判断是否为空 clear() 清空 rfind 反向查找 string substr (size_t pos = 0, size_t len = npos) const; 返回一个子串 const char * c_str() const 将string对象转化为C语言格式的字符串]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL映射与多重映射]]></title>
    <url>%2F2019%2F05%2FSTL%E6%98%A0%E5%B0%84%E4%B8%8E%E5%A4%9A%E9%87%8D%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。 头文件1#include&lt;map&gt; 构造函数（map&lt;key, val&gt; mapT）1map&lt;int, string&gt; mapStudent; 迭代器 iterator vec.begin(); iterator vec.end(); //末尾指针，指向最后一个元素的下一个位置 const_iterator vec.cbegin(); //指向常量的开始指针，意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。 const_iterator vec.cend(); //指向常量的末尾指针 reverse_iterator vec.rbegin() //逆向迭代器的开始指针 reverse_iterator vec.rend(); //逆向迭代器的尾指针 const_reverse_iterator vec.crbegin() //逆向迭代器的开始指针,指向常量 const_reverse_iterator vec.crend(); //逆向迭代器的尾指针,指向常量123456789//前向迭代map&lt;int, string&gt;::iterator iter;for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;' '&lt;&lt;iter-&gt;second&lt;&lt;endl; //反向迭代map&lt;int, string&gt;::reverse_iterator iter; for(iter = mapStudent.rbegin(); iter != mapStudent.rend(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;" "&lt;&lt;iter-&gt;second&lt;&lt;endl; 常用操作容量 size() 1map&lt;int, string&gt;::size_type nSize = mapStudent.size(); bool empty()如果map为空则返回true max_size()返回可以容纳的最大元素个数 遍历利用用迭代器或者数组的方式进行遍历12345for(int nindex = 1; nindex &lt;= nSize; nindex++) cout&lt;&lt;mapStudent[nindex]&lt;&lt;endl;// 此处应注意，// 应该是 for(int nindex = 1; nindex &lt;= nSize; nindex++) // 而不是 for(int nindex = 0; nindex &lt; nSize; nindex++) 插入 用insert函数插入pair数据 123mapStudent.insert(pair&lt;int, string&gt;(1, "student_one"));mapStudent.insert(pair&lt;int, string&gt;(3, "student_three"));mapStudent.insert(make_pair(2, "student_two"); 用insert函数插入value_type数据 1mapStudent.insert(map&lt;int, string&gt;::value_type (1, "student_one"));mapStudent.insert(map&lt;int, string&gt;::value_type (3, "student_three")); 用数组方式插入数据 12mapStudent[1] = "student_one"; mapStudent[3] = "student_three"; 查找iterator find(const key_type&amp; k)函数来定位数据出现位置，它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器。12345iter = mapStudent.find(1); if(iter != mapStudent.end()) cout&lt;&lt;"Find, the value is "&lt;&lt;iter-&gt;second&lt;&lt;endl; else cout&lt;&lt;"Do not Find"&lt;&lt;endl; 删除* iterator erase（iterator it); //通过一个条目对象删除 * iterator erase（iterator first，iterator last） //删除一个范围 * size_type erase(const Key&amp;key); //通过关键字删除 * clear() //全部清除 其他成员函数： count()返回指定元素出现的次数 size_type count (const key_type&amp; k) const; swap() lower_bound() upper_bound() (具体见http://www.cplusplus.com/reference/map/map/)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL仿函数]]></title>
    <url>%2F2019%2F05%2FSTL%E4%BB%BF%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[简介仿函数，也叫函数对象。函数指针毕竟不能满足STL对抽象性的要求，也不能满足软件积木的要求——函数指针无法和STL其他组件（如配接器adapter）搭配，产生更灵活的变化。同时，函数指针无法保存信息，而仿函数可以。就实现观点而言，仿函数其实上就是一个“行为类似函数”的对象。为了能够“行为类似函数”，其类别定义中必须自定义（或说改写，重载）function call运算子（operator()）。拥有这样的运算子后，我们就可以在仿函数的对象后面加上一对小括号，以此调用仿函数所定义的operator()。具体如下：12345678910#include &lt;functional&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; greater&lt;int&gt; ig; cout &lt;&lt; boolalpha &lt;&lt; ig(4, 6); cout &lt;&lt; greater&lt;int&gt;()(6, 4); return 0;&#125; 其中第一种用法比较为大家所熟悉，greater ig的意思是产生一个名为ig的对象，ig(4, 6)则是调用其operator()，并给予两个参数4和6。第二种用法中的greater() 意思是产生一个临时（无名的）对象，之后的(6, 4)才是指定两个参数6,5。上述第二种语法在一般情况下不常见，但是对仿函数而言，却是主流用法。（STL中的仿函数绝大部分采用这种用法） 头文件1#include &lt;functional&gt; 任何应用程序欲使用STL内建的仿函数，都必须含入头文件，SGI则将它们实际定义于&lt;stl_function.h&gt;文件中。 STL仿函数的分类 若以操作数的个数划分，可分为一元和二元仿函数； 若以功能划分，可分为算术运算、关系运算、逻辑运算三大类。 自定义仿函数12345678910111213141516171819typedef struct &#123; int a,b; char s;&#125; newtype;struct compare &#123; //重载() bool operator()(const newtype &amp;a, const newtype &amp;b) const &#123; return a.s&lt;b.s; &#125;&#125;;newtype obj1, obj2;//方式1compare comp;comp(obj1, obj2);//方式2compare()(obj1, obj2); functional头文件中常用的仿函数Operator classes are classes that define functional objects that call operators http://www.cplusplus.com/reference/functional/ table th:first-of-type { width: 100px; } 函数名 意义 bit_and Bitwise AND function object class (class template ) bit_or Bitwise OR function object class (class template ) bit_xor Bitwise XOR function object class (class template ) divides Division function object class (class template ) equal_to Function object class for equality comparison (class template ) greater Function object class for greater-than inequality comparison (class template, e.g. greater()) greater_equal Function object class for greater-than-or-equal-to comparison (class template ) less Function object class for less-than inequality comparison (class template, e.g. less()) less_equal Function object class for less-than-or-equal-to comparison (class template ) logical_and Logical AND function object class (class template ) logical_not Logical NOT function object class (class template ) logical_or Logical OR function object class (class template ) minus Subtraction function object class (class template ) modulus Modulus function object class (class template ) multiplies Multiplication function object class (class template ) negate Negative function object class (class template ) not_equal_to Function object class for non-equality comparison (class template ) plus Addition function object class (class template ) 算数操作符plus 加法函数对象，等价于 x + y minus 减法函数对象，等价于 x - y multiplies 乘法函数对象，等价于 x * y divides 除法函数对象，等价于 x / y modulus 取模函数对象，等价于 x % y negate 取相反数函数对象，等价于 -x 比较equal_to 函数对象，等价于 x == y not_equal_to 函数对象，等价于 x != y greater 函数对象，等价于 x &gt; y less 函数对象，等价于 x &lt; y greater_equal 函数对象，等价于 x &gt;= y less_equal 函数对象，等价于 x &lt;= y 逻辑操作logical_and 函数对象，等价于 x &amp;&amp; y logical_or 函数对象，等价于 x || y logical_not 函数对象，等价于 !x按位操作 bit_and 函数对象，等价于 x &amp; y bit_or 函数对象，等价于 x | y bit_xor 函数对象，等价于 x ^ y 否认操作unary_negate 封装函数对象，返回一元谓词（Unary predicate）所表示范围的补（Complement） binary_negate 封装函数对象，返回二元谓词所表示范围的补 not1 构造自定义 unary_negate 对象 not2 构造自定义 binary_negate 对象]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL迭代器]]></title>
    <url>%2F2019%2F05%2FSTL%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[头文件1#include&lt;iterator&gt; 迭代器类别输入迭代器(Input iterator)只能一次一个向前读取元素，按此顺序一个个传回元素值。下表列出了Input迭代器的各种操作行为。Input迭代器只能读取元素一次，如果你复制Input迭代器，并使原Input迭代器与新产生的副本都向前读取，可能会遍历到不同的值。纯粹Input迭代器的一个典型例子就是“从标准输入装置（通常为键盘）读取数据”的迭代器。 table th:first-of-type { width: 100px; } 表达式 功能表述 *iter 读取实际元素 iter-&gt;member 读取实际元素的成员（如果有的话） ++iter 向前步进（传回新位置） iter++ 向前步进（传回旧位置） iter1 == iter2 判断两个迭代器是否相同 iter1 != iter2 判断两个迭代器是否不相等 TYPE(iter) 复制迭代器（copy 构造函数） 输出迭代器(Output iterator)Output迭代器和Input迭代器相反，其作用是将元素值一个个写入。表2.2列出Output迭代器的有效操作。operator* 只有在赋值语句的左手边才有效。Output迭代器无需比较（comparison）操作。你无法检验Output迭代器是否有效，或“写入动作”是否成功。你唯一可以做的就是写入、写入、再写入。 表达式 功能表述 *iter = value 将元素写入到迭代器所指位置 ++iter 向前步进（传回新位置） iter++ 向前步进（传回旧位置） TYPE(iter) 复制迭代器（copy 构造函数） 前向迭代器(Forward iterator)Forward迭代器是Input迭代器与Output迭代器的结合，具有Input迭代器的全部功能和Output迭代器的大部分功能。表2.3总结了Forward迭代器的所有操作。Forward迭代器能多次指向同一群集中的同一元素，并能多次处理同一元素。 表达式 功能表述 *iter 存取实际元素 iter-&gt;member 存取实际元素的成员 ++iter 向前步进（传回新位置） iter++ 向前步进（传回旧位置） iter1 == iter2 判断两个迭代器是否相同 iter1 != iter2 判断两个迭代器是否不相等 TYPE() 产生迭代器（default构造函数） TYPE(iter) 复制迭代器（copy构造函数） iter1 == iter2 复制 双向迭代器(Bidirectional iterator)Bidirectional（双向）迭代器在Forward迭代器的基础上增加了回头遍历的能力。换言之，它支持递减操作符，用以一步一步的后退操作。 随机访问迭代器(Random access iterator)Random Access迭代器在Bidirectional迭代器的基础上再增加随机存取能力。因此它必须提供“迭代器算数运算”（和一般指针“指针算术运算”相当）。也就是说，它能加减某个偏移量、能处理距离（differences）问题，并运用诸如&lt;和&gt;的相互关系操作符进行比较。以下对象和型别支持Random Access迭代器： 可随机存取的容器（vector, deque） strings（字符串，string，wstring） 一般array（指针） 迭代器相关辅助函数123456void advance (InputIterator&amp; it, Distance n); //令迭代器前进n步difference_type distance (InputIterator first, InputIterator last); // 处理迭代器之间的距离begin(a) // 获取指向容器或者数组起点的迭代器(C++11)end(a) // 获取指向容器或者数组终点的迭代器(C++11)BidirectionalIterator prev (BidirectionalIterator it,difference_type n = 1); // 另迭代器逆向移动n步(C++11)ForwardIterator next (ForwardIterator it,difference_type n = 1); // 另迭代器正向移动n步(C++11) 其他类型的迭代器插入迭代器插入迭代器调用容器的操作push_back()、push_front()、insert()来向给定容器的指定位置插入一个元素12345678container c;value_type t;auto bit = back_inserter(c); //创建一个使用push_back()的迭代器*bit = t; //调用c.push_back(t)auto fit = front_inserter(c); //创建一个使用push_front()的迭代器*fit = t; //调用c.push_front(t)auto it = inserter(c, c.begin()); //创建一个使用insert()的迭代器*it = t; //调用c.insert(p, t) iostream迭代器 istream_iterator in(is), end; //in从输入流读取类型为T的值，end表示尾后位置 *in //返回从流中读取的值 123//计算从标准输入读取的值的和istream_iterator&lt;int&gt; in(cin), eof;cout &lt;&lt; accumulate(in, eof, 0) &lt;&lt; endl; ostream_iterator out(os); //out将类型为T的值写到输出流os中 ostream_iterator out(os, d); //out将类型为T的值写到输出流os中，每个值后面输出一个d，d指向一个空字符结尾的字符数组 out = val; //用&lt;&lt;将val写入到out所绑定的ostream中12345//将vec中的每个元素输出到coutostream_iterator&lt;int&gt; out(cout, " ");for(auto e:vec) *out++ = e;cout &lt;&lt; endl; 反向迭代器移动迭代器解引用后生产一个右值，用于调用移动构造函数或移动赋值函数，以提高效率。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL集合与多重集合]]></title>
    <url>%2F2019%2F05%2FSTL%E9%9B%86%E5%90%88%E4%B8%8E%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[set是STL中一种标准关联容器。它底层使用平衡的搜索树——红黑树实现，插入删除操作时仅仅需要指针操作节点即可完成，不涉及到内存移动和拷贝，所以效率比较高，时间复杂度均为O(logn)。 set，顾名思义是“集合”的意思，在set中元素都是唯一的，而且默认情况下会对元素自动进行升序排列，支持集合的交(set_intersection)、差(set_difference) 、并(set_union)、对称差(set_symmetric_difference) 等一些集合上的操作，如果需要集合中的元素允许重复那么可以使用multiset。 自动排序的优点是使得搜寻元素时具有良好的性能，具有对数时间复杂度。但是造成的一个缺点就是：不能直接改变元素值。因为这样会打乱原有的顺序。改变元素值的方法是：先删除旧元素，再插入新元素。存取元素只能通过迭代器，从迭代器的角度看，元素值是常数。 头文件1#include&lt;set&gt; 构造函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;typedef struct &#123; int a,b; char s;&#125; newtype;//自定义比较函数struct compare//there is no ().&#123; //重载() bool operator()(const newtype &amp;a, const newtype &amp;b) const &#123; return a.s&lt;b.s; &#125;&#125;;set&lt;newtype,compare&gt; element;int main()&#123; newtype a,b,c,d,t; a.a=1; a.s='b'; b.a=2; b.s='c'; c.a=4; c.s='d'; d.a=3; d.s='a'; element.insert(a); element.insert(b); element.insert(c); element.insert(d); set&lt;newtype,compare&gt;::iterator it; for(it=element.begin(); it!=element.end();it++) cout&lt;&lt;(*it).a&lt;&lt;" "; cout&lt;&lt;endl; for(it=element.begin(); it!=element.end();it++) cout&lt;&lt;(*it).s&lt;&lt;" "; return 0;&#125; 迭代器： s.begin() 返回指向set容器中第一个元素的迭代器 s.end() 返回指向set容器的最后一个元素迭代器 s.rbegin() 返回指向set容器中最后一个元素的反向迭代器 s.rend() 返回指向set容器的第一一个元素前的反向迭代器 常用操作容量 s.size()返回当前set容器中的元素个数 s.empty()判断set容器是否为空 s.max_size()返回最大值 修改： s.insert() 1234pair&lt;iterator, bool&gt; insert(const value_type&amp; val); // set调用，返回值可用于判断是否插入成功iterator insert(const value_type&amp; val); // multiset调用，返回值可用于判断是否插入成功iterator insert(const_iterator position, const value_type&amp; val);void insert(InputIterator first, InputIterator last); s.erase() 12345size_type erase (const value_type&amp; val); // 删除一个元素 void erase (iterator position); // 删除某个位置的元素void erase (iterator first, iterator last); // 删除某个范围内的元素s.clear() // 删除set容器中的所有的元素 s.swap() 其他操作： iterator find(const value_type&amp; val) const;查找一个元素，如果容器中不存在该元素，返回值等于end() size_type count (const value_type&amp; val) const;返回某个元素的个数，由于set元素的唯一性，所以该函数总是返回0或者1；对于multiset则返回val元素的个数。 lower_bound() upper_bound()]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL栈]]></title>
    <url>%2F2019%2F05%2FSTL%E6%A0%88%2F</url>
    <content type="text"><![CDATA[C++ Stack（堆栈） 是一个容器类的改编，为程序员提供了堆栈的全部功能，——也就是说实现了一个先进后出（FILO）的数据结构。 头文件1#include &lt;stack&gt; 创建 stack()默认的构造函数，如stack s;使用默认的 deque 为底层容器，创建一个空的堆栈对象 s stack(const stack&amp;)复制构造函数，用一个 stack 堆栈创建一个新的堆栈。stack&lt;int, list&lt;int&gt;&gt; s2(s1);利用 s1，创建一个以双向链表为底层容器的空堆栈对象 s2 。 成员函数介绍（操作 比较和分配堆栈） bool empty()判断堆栈是否为空，返回 true 表示堆栈已空，false 表示堆栈非空。 void pop()移除栈顶元素 void push(const value_type&amp; x)在栈顶增加元素 size()返回栈中元素数目 value_type&amp; top()返回栈顶元素]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL双端队列]]></title>
    <url>%2F2019%2F05%2FSTL%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[简介deque 双端队列容器 ( double-ended queue ) 与 vector 非常相似，不仅可在尾部插入和删除元素，还可以在头部插入和删除，算法的时间复杂度也是常数阶 O(1),是一个实现了 Random access container 、Back insertion sequence 和 Front insertion sequence 概念的模型。 deque 内部的数据机制和执行性能与 vector 不同，一般来说，当考虑到容器元素的内存分配策略和操作的性能时，deque 相对 vector 有优势。 头文件1#include &lt;deque&gt; 初始化方式12345deque()deque(size_type n)deque(size_type n, const T&amp; value)deque(const deque&amp;)deque(const InputIterator first, const InputIterator last) 获取迭代器 iterator begin() iterator end() reverse_iterator rbegin() //返回逆向迭代器 reverse_iterator rend() const_iterator cbegin() //返回常量迭代器，不能修改迭代器指向的值 const_iterator cend() const_reverse_iterator crbegin() //返回常量逆向迭代器，不能修改迭代器指向的值 const_reverse_iterator crend() 常用操作容量 size() max_size() resize() empty() shrink_to_fit() 访问访问deque 的元素同样可采用数组、 .at() 函数或者迭代器的方式进行访问 operator [ ] at front() back() 插入与删除 void push_front() push_back() pop_front() void pop_back() insert() iterator erase(iterator pos) iterator erase(iterator first, iterator last) void clear() swap()]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL双向链表]]></title>
    <url>%2F2019%2F05%2FSTL%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[头文件1#include&lt;list&gt; 构造函数1234list&lt;T&gt; lstT; //如list&lt;int&gt; lstInt;list&lt;int&gt; ls(n, val);list&lt;int&gt; ls(InputIterator first, InputIterator last);lsit&lt;int&gt; ls(const list&lt;int&gt; &amp; ls) 迭代器12345678iterator vec.begin();iterator vec.end(); //末尾指针，指向最后一个元素的下一个位置const_iterator vec.cbegin(); //指向常量的开始指针，意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。const_iterator vec.cend(); //指向常量的末尾指针reverse_iterator vec.rbegin() //逆向迭代器的开始指针reverse_iterator vec.rend(); //逆向迭代器的尾指针const_reverse_iterator vec.crbegin() //逆向迭代器的开始指针,指向常量const_reverse_iterator vec.crend(); //逆向迭代器的尾指针,指向常量 基本操作容量123bool empty() //判断list是否为空size_t size()size_t max_size() 元素访问12reference front() //获得list容器中的头部元素reference back() //获得list容器的最后一个元素 当list元素为空时，这时候调用front()和back()不会报错。因此在编写程序时，最好先调用empty()函数判断list是否为空，再调用front()和back()函数。 元素修改1234567void push_back(elem); //在容器尾部加入一个元素void pop_back(); //删除容器中最后一个元素 void push_front(elem); //在容器开头插入一个元素 void pop_front(); //从容器开头移除第一个元素 void resize() //调用resize(n)将list的长度改为只容纳n个元素，超出的元素将被删除。如果n比list原来的长度长，那么默认超出的部分元素置为0。也可以用resize(n, m)的方式将超出的部分赋值为m。void clear() // 清空list中的所有元素void swap(list &amp;) // 交换两个链表。a.swap(b)和swap(a, b)，都可以完成a链表和b链表的交换。 insert() 插入操作123iterator insert (iterator position, const value_type&amp; val); // 插入单个元素void insert (iterator position, size_type n, const value_type&amp; val); // 插入多个相同的元素void insert (iterator position, InputIterator first, InputIterator last); // 插入某个范围内的元素 erase()删除操作12iterator erase (iterator position);iterator erase (iterator first, iterator last); 成员函数123456789void reverse() // 可以实现list的逆置，如reverse(b.begin(),b.end()); void merge(list &amp;) // 合并两个链表，如a.merge(b) 调用结束后b变为空，a中元素包含原来a和b的元素。void sort() // 排序void remove (const value_type&amp; val); // 移除所有值为val的元素 void unique() // 元素去重splice() // 实现拼接功能void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x ); void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x, iterator i );void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x, iterator first, iterator last );]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生最美是清欢]]></title>
    <url>%2F2019%2F05%2F%E4%BA%BA%E7%94%9F%E6%9C%80%E7%BE%8E%E6%98%AF%E6%B8%85%E6%AC%A2%2F</url>
    <content type="text"><![CDATA[人间有味，最是清欢细雨斜风作小寒，淡烟疏柳媚晴滩，入淮清洛渐漫漫。雪沫乳花浮午盏，蓼茸篙笋试春盘，人间有味是清欢。 ——苏轼 人生只似风前絮，欢也零星，悲也零星，都做连江点点萍。 ——王国维 山中何所有？领上多白云。只可自怡悦，不堪持赠君。 天寒翠袖薄，日暮倚修竹。 怎么向从来没见过雪的人描述雪？ 我们要知道雪，只有自己到有雪的国度；我们要听到黄莺的歌声，就要坐到有黄莺的树下；我们要问夜来香的清气，只有夜晚走到有花的庭院。 雪，冷面清明，纯净优美，念念不往，在某一层次上，像极了我们的心。 活在当下，自在宁静山有多高，月就有多小；云有多重，愁就有多深；而夕阳 夕阳就只有一寸 我们为了太多紧急的事，只好牺牲看来不甚紧急的事，例如为了加班，牺牲应有的睡眠；为了业绩牺牲吃饭时间；为了应酬，不能陪家人散步，为了谋取职位，不能与朋友喝茶。确实，紧急的事不能不做，奈何人生里紧急的事无穷无尽，我们的一生大半的在紧急的应付中度过，到最后整个生活步调都变得很紧急了。 一个人如果在一天里花了八个小时在追逐衣食与俗世上，是不是也能画八十分钟来思考重要的事情呢？如若不行，就从八分钟开始。 天寒露重，望君保重风来疏竹，风过而竹不留声；雁渡寒潭，雁去而潭不留影。故君子事来而心始现，事去而心随空。 爱的开始是一个眼色，爱的最后是无限的苍穹 简单 而有丰沛的爱平常 而有深刻的心 岁月静好，随遇而安温柔半两，从容一生正视每一个眼前的生活历程，努力地活在当下，对这一阶段的人生与情感用心珍惜。 在被造谣时，我不着急，因为我有自知之明；在被误解时，我不着急，因为我有自觉之道；在被毁谤时，我不着急，因为我有自爱之方；在被打击时，我不着急，因为我有自愉之法。 生命的一切成长，都需要时间。 生命的幸福原来不在于人的环境、人的地位、人所能享受的物质，而在于人的心灵如何与生活应对。 我们幸福的感受不全然是世界所给予的，而是来自我们对外在或者内在的价值判断。我们幸福与否，正是由自我的价值观来决定。 不忘初心，方得始终万事万物都有其自然的法则，依循这自然的发展，常常回头看看自己的脚跟，才是生命成长正常的态度。“不雨花犹落，无风絮自飞”，花与絮的飞落不必因为风雨，而是它已进入了生命的时序。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>名句摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2019%2F05%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[概念Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 工作区：在电脑里能看到的目录 版本库：版本库里包含被称为stage的暂存区以及git自动创建的第一个分支master以及指向master的一个指针HEAD。 初始化配置 安装好git之后通过如下命令配置用户名和email 12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 查看配置内容 123$ git config --system --list # 查看系统config$ git config --global --list # 查看用户config$ git config --local --list # 查看本地仓库config 创建及提交 初始化一个Git仓库，使用git init命令。 123$ mkdir learngit$ cd learngit$ git init 添加文件到git仓库 方式1：先添加到暂存区，再提交 1234$ git add &lt;file&gt;$ git rm -cached &lt;file&gt; # 取消添加，可以从暂存区删除文件$ git commit -m "description" 方式2：直接提交 1$ git commit -a -m "description" 直接覆盖上一次提交信息 1$ git commit -a --amend #只会有一次提交 合并多次提交为一次提交 1git rebase -i commit_id # commit_id想要合并的提交的前一次的ID 信息查询跟踪工作区的修改12$ git status # 列出哪些文件被修改$ git diff &lt;file&gt; # 文件被修改的内容 查看提交记录12$ git log # 提交记录$ git reflog # 记录每一次修改操作 git log的常用选项说明 table th:first-of-type { width: 100px; } 选项 说明 -p 按补丁格式显示每个更新之间的差异。 –stat 显示每次更新的文件修改统计信息。 –shortstat 只显示 –stat 中最后的行数修改添加移除统计。 –name-only 仅在提交信息后显示已修改的文件清单。 –name-status 显示新增、修改、删除的文件清单。 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 –graph 显示 ASCII 图形表示的分支合并历史。 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和format（后跟指定格式）。 版本回退 指定版本号 1$ git reset --hard commit_id commit_id可用 git log 和 git reflog 两个命令来查询，一般填写前7位即可，git会自动去匹配，知识要保证提供的commit_id可被git区分。 相对版本回退 1$ git reset --hard HEAD^ 在Git中，用HEAD表示当前版本，一般指向最新的提交的版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 撤销修改 修改了工作区的文件还没有提交到缓存区 1git checkout -- file命令。 命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，在后面的分支管理中会再次遇到git checkout命令。 修改了工作区文件并提交到了缓存区，但是没有使用commit提交到分支上1) 用命令 git reset HEAD file 就回到了场景12) 按场景1操作 12$ git reset HEAD readme.txt$ git checkout -- readme.txt 已经提交到了版本库的分支上，参考版本回退章节的内容 删除文件Git中删除也是一个修改操作。直接删除本地文件后，工作区和版本库不一致，这时候有两种选择： 删除版本库中相应的文件 12$ git rm &lt;file&gt;$ git commit -m "Remove" 从版本库中恢复被删除的文件 1$ git checkout -- &lt;file&gt; 分支管理Git鼓励大量使用分支 分支常用操作 查看分支： 1$ git branch # 加-v后缀可查看每一个分支的最后一次提交 创建分支 1$ git branch &lt;branch name&gt; 切换分支： 1$ git checkout &lt;branch name&gt; 在切换分支时，一定要注意你工作目录里的文件会被改变。如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。 创建+切换分支： 1$ git checkout -b [branch] [remote name]/[branch] 合并某分支到当前分支： 1$ git merge &lt;branch name&gt; 删除分支： 1$ git branch -d &lt;branch name&gt; 删除远程分支： 1git push [remote name] --delete [remote branch] 变基（rebase）将当前分支合并到其他分支并使得提交历史变得简洁 将分支b变基到分支a上过程如下： 12345$ git checkout &lt;branch b&gt;$ git rebase &lt;branch a&gt;# 以下两步用于前移a分支的head$ git checkout &lt;branch a&gt;$ git merge &lt;branch b&gt; 解决rebase冲突 1234$ git diff$ # 修改冲突的内容$ git add &lt;file&gt;$ git rebase --continue 远程仓库 关联远程仓库 12345$ git remote add origin &lt;远程仓库地址&gt; # 添加远程仓库$ git remote -v # 查看远程仓库信息$ git remote rm &lt;仓库名&gt; # 删除远程仓库$ git remote &lt;仓库名&gt; set-url &lt;远程仓库地址&gt; # 修改远程仓库的链接$ git remote rename &lt;remote-name&gt; &lt;new-name]&gt; # 远程仓库重命名 抓取与推送 git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 从远程仓库指定分支中拉取所有你还没有的数据保存到本地分支中。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 自动的抓取然后合并远程分支到当前分支 git push &lt;remote-name&gt; &lt;branch-name&gt; 将当期分支推送到远程仓库的指定分支中 git push -u origin master 第一次推送master分支的所有内容；（加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。） 远程仓库强制覆盖本地修改 123$ git fetch -all$ git reset --hard origin/master # 指定远程分支origin/dev_liutao$ git pull origin dev_liutao 推送修改后的分支到远程仓库 123$ git fetch$ git rebase origin/master$ git push]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>版本管理</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL队列]]></title>
    <url>%2F2019%2F05%2FSTL%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[头文件1#include&lt;queue&gt; 构造函数1queue&lt;T&gt; que; 成员函数123456void push(const value_type&amp; val); // 将元素置入queue中。 void pop(); // 会从queue中移除一个元素（也就是第一个被置入的元素）。value_type front(); // 会返回queue内的下一个元素（也就是第一个被置入的元素）。value_type back(); // 会返回queue的最后一个元素（也就是最后一个被插入的元素）。size_type size() const; // 返回stack长度。bool empty() const; // 返回stack是否为空。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL向量]]></title>
    <url>%2F2019%2F05%2FSTL%E5%90%91%E9%87%8F%2F</url>
    <content type="text"><![CDATA[头文件1#include &lt;vector&gt; 声明及初始化12345678910vector&lt;int&gt; vec; // 声明一个int型向量vector&lt;int&gt; vec(5); // 声明一个初始大小为5的int向量，向量元素执行默认初始化vector&lt;int&gt; vec(10, 1); // 声明一个初始大小为10且值都是1的向量vector&lt;int&gt; vec(tmp); // 声明并用tmp向量初始化vec向量vector&lt;int&gt; tmp(vec.begin(), vec.begin() + 3); // 用向量vec的第0个到第2个值初始化tmpint arr[5] = &#123;1, 2, 3, 4, 5&#125;;vector&lt;int&gt; vec(arr, arr + 5); /* 将arr数组的元素用于初始化vec向量(说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，这个主要是为了和vec.end()指针统一。)*/vector&lt;int&gt; vec(&amp;arr[1], &amp;arr[4]); // 将arr[1]~arr[4]范围内的元素作为vec的初始值 基本操作容量（capacity）与长度（size）size指容器当前拥有的元素个数；capacity则指容器在必须分配新存储空间之前可以存储的元素总数,也可以说是预分配存储空间的大小。 向量长度：vec.size(); 向量支持的最大容量： vec.max_size(); 更改向量长度： 12vec.resize(n); // 将向量的大小改为n。（当n小于当前长度则擦除后续部分，但vec的容量不变；n大于当前长度则插入新元素，新元素设为默认值；若n超出当前向量分配的容量，则会将当前容量扩容至n。）vec.resize(n, t); // 作用与上一函数相同，只是将新元素的值设置为t 保留适当容量：vec.reserve(n); // 预分配n个元素的存储空间。（当n大于当前容量时则将容量扩充至n；当n小于等于当前容量时则无变化。容器调用resize()函数后，所有空间都已经初始化可以直接访问，而调用reserve()函数预先分配出的空间没有被初始化，所以不可以直接访问） 向量真实容量：vec.capacity(); 向量判空： vec.empty(); 减少向量容量到满足元素所占存储空间的大小： vec.shrink_to_fit(); //shrink_to_fit 修改 多元素赋值：vec.assign(iterator first, iterator last) // 将[first, last)之间的值赋值给vec 末尾添加元素：void vec.push_back(elem) 末尾删除元素：void vec.pop_back(elem) 插入元素： iterator vec.insert() // 返回一个指向第一个新插入元素的迭代器 12345iterator insert (const_iterator position, const value_type&amp; val); //single elementiterator insert (const_iterator position, size_type n, const value_type&amp; val); // fill iterator insert (const_iterator position, InputIterator first, InputIterator last); // rangeiterator insert (const_iterator position, value_type&amp;&amp; val); //moveiterator insert (const_iterator position, initializer_list&lt;value_type&gt; il); //initializer list 任意位置删除元素： vec.erase(); 交换两个向量的元素： vec.swap(); 清空向量元素： vec.clear(); 迭代器12345678910iterator vec.begin();iterator vec.end(); //末尾指针，指向最后一个元素的下一个位置const_iterator vec.cbegin(); /*指向常量的开始指针，意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。*/const_iterator vec.cend(); //指向常量的末尾指针reverse_iterator vec.rbegin() //逆向迭代器的开始指针reverse_iterator vec.rend(); //逆向迭代器的尾指针const_reverse_iterator vec.crbegin() //逆向迭代器的开始指针,指向常量const_reverse_iterator vec.crend(); //逆向迭代器的尾指针,指向常量 元素访问 下标访问： vec[1]; //并不会检查是否越界 at方法访问： vec.at(1); //以上两者的区别就是at会检查是否越界，是则抛出out of range异常 访问第一个元素： vec.front(); 访问最后一个元素： vec.back(); 返回一个指针： int* p = vec.data(); //可行的原因在于vector在内存中就是一个连续存储的数组，所以可以返回一个指针指向这个数组。这是是C++11的特性。 应用 遍历元素 1234567vector&lt;int&gt;::iterator it;for (it = vec.begin(); it != vec.end(); it++) cout &lt;&lt; *it &lt;&lt; endl;//或者for (size_t i = 0; i &lt; vec.size(); i++) &#123; cout &lt;&lt; vec.at(i) &lt;&lt; endl;&#125; 元素翻转 12#include &lt;algorithm&gt;reverse(vec.begin(), vec.end()); 元素排序 12345#include &lt;algorithm&gt;sort(vec.begin(), vec.end()); //采用的是从小到大的排序//如果想从大到小排序，可以采用上面反转函数，也可以采用下面方法:bool Comp(const int&amp; a, const int&amp; b) &#123;return a &gt; b;&#125;sort(vec.begin(), vec.end(), Comp);]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL简介]]></title>
    <url>%2F2019%2F04%2FSTL%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[STL（Standard Template Library）标准模板库的简称，是由惠普开发的一系列软件的总称，STL现在是C++的一部分，已经被构建于编译系统之内，所以不需要再引入。 STL的组成部分 容器（containers）：是一种数据结构容器，使用类模板的方式提供，我们可以方便的进行数据的存储操作。 适配器（adapters）：以序列式容器为基础，提供的栈，队列和优先级队列的这种容器。 迭代器（iterators）：类似于指针，用来操作容器的对象。 算法（algorithm）：包含一系列的常见算法。 空间配置器（allocator）：其中主要工作包括两部分：1、对象的创建与销毁。2、内存的创建与释放。 仿函数（functor）：仿函数又称为函数对象，其实就是重载了()操作符的struct，没有什么特别的地方。 容器 序列式容器：每个元素都有固定位置，取决于插入时机和地点。与元素值无关。 vector（向量）：底层数据结构是数组，可以随机存取数据元素（用索引直接存取），数组的尾部添加和移除元素很快，但在头部和中部插入元素比较耗时。 deque（双端队列）：底层数据结构是数组，可以随机存取数据元素，在数组的头部和尾部插入和删除元素很快。 list（列表）：底层数据结构是双向链表，不提供随机存取数据元素（需要按顺序走到要存取的元素），在任何位置插入和删除都很快，只需要简单的移动一下指针。 forward_list：单向链表 array：固定大小的数组 string：字符串 关联式容器：元素位置取决于特定的排序准则，和插入的顺序无关，底层数据结构为二叉树。 set（集合）：内部元素依据其值自动排序，set内相同的数值元素只能出现一次。 multiset（多重集合）：内部元素依据其值自动排序，set内允许出现重复的元素。 map（映射）：map的元素是成对的键值对，内部元素的值依据键自动排序，键只允许出现一次。 multimap（多重映射）：多重映射是map的增强版，内部元素的值依据键自动排序，允许键出现多次。 bitset 无序的关联式容器，使用hash函数来组织元素 unordered_set unordered_map unordered_multiset unordered_multimap 适配器STL提供了三种适配器stack，queue和priority_queue。这些适配器是包装了序列式容器（vector，deque，list）中的一种。因此所谓的适配器就是序列式容器的包装器，注意：适配器没有提供迭代器。 stack（栈）：栈可以使用序列式容器中的vector，deque，list中的任意一种作为其底层的数据结构。默认是使用deque来实现的stack。 queue（队列）：队列可以使用deque和list中的任意一种作为其底层的数据结构。默认是使用deque来实现的queue。 priority_queue（优先队列）：优先队列也是一种队列，不过在进入队列之后会对元素进行排序，可以使用vector和deque来实现其底层结构，默认是使用vector来实现priority_queue。 名称 底层数据结构 查询速度 插入和删除的速度 序列式容器 vector（向量） 数组 快 尾部插入删除快，其他慢 deque（双端队列） 数组 快 头尾插入删除快，其他慢 list（列表） 链表 慢 任何位置插入删除都很快 容器适配器 stack（栈） deque（默认） ~ ~ queue（队列） deque（默认） ~ ~ priority_queue（优先队列） vector（默认） ~ ~ 关联式容器 set（集合） 二叉树 很快 ~ multiset（多重集合） 二叉树 很快 ~ map（映射） 二叉树 很快 ~ multimap（多重映射） 二叉树 很快 ~ 迭代器迭代器(Iterator)是指针(pointer)的泛化，它允许程序员以相同的方式处理不同的数据结构(容器)。STL中有五种类型的迭代器，它们分别满足一定的要求。不同的迭代器要求定义的操作不一样。 输入迭代器(Input iterator) 输出迭代器(Output iterator) 前向迭代器(Forward iterator) 双向迭代器(Bidirectional iterator) 随机访问迭代器(Random access iterator) 各个迭代器之间的功能关系如下图所示，越往下越丰富 input output \ / forward | bidirectional | random access]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客操作]]></title>
    <url>%2F2019%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[搭建步骤 安装node.js和git 安装Hexo 1$ npm install -g hexo-cli 建站 1234$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install$ hexo s // 本地运行，通过浏览器预览 新建博文 123$ hexo new "My New Post"$ hexo clean$ hexo generate 部署到远端站点 编辑站点配置文件_config.yml 123456#Deployment#Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/liuxiutao/liuxiutao.github.io.git branch: master 部署 1$ Hexo deploy NexT主题 下载主题 1$ git clone https://github.com/theme-next/hexo-theme-next themes/next/ 修改主题配置文件配置主题 常用命令 新建博文 1$ hexo new "My New Post" 更多信息: Writing 本地运行服务 1$ hexo server More info: Server 调试模式 1$ hexo s --debug 清空历史记录 1$ hexo clean 生成静态文件 1$ hexo generate More info: Generating 部署到远端站点 1$ hexo deploy More info: Deployment 新建分类页面 1$ hexo new page categories]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
